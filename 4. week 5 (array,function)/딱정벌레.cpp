#include<iostream>
#include<ctime>//srand()를 사용하기 위해 선언

using namespace std;

void bug_walk(int b[5][5]);//벌레 이동 변화 함수 *배열 자체를 변화시켜야 함으로 주소를 받기위해 const를 쓰지 않는다. 
int rand_walk(void);//벌레의 이동방향 0~7을 랜덤으로 고르는 함수
int count_walk(const int c[5][5]);//총 이동횟수을 세는 함수
int check_string(const int d[5][5]);//종료을 위해 벌레가 타일을 모두 지났는지 확인하는 함수
void find_fist_tile(int t_t[5][5]);//가장많이 지난 타일을 찾는 함수
void out_tile(int aa[5][5]);//각 타일별 벌레의 이동 횟수를 출력하는 함수

int n = 2, m = 2;//배열의 정 중앙 좌표 bug_walk 함수에서 변화를 줄것이기 때문에 "전역변수"로 선언 bug[n][m]이다.
int walk;//rand_walk함수의 결과값을 받는 변수 여러함수에서 사용하기 위해 "전역변수"로 선언 
int big1, big2;//find_fist_tile함수에서 찾은 좌표를 받을 변수

int main()//Main 함수 
{
    int bug[5][5] = { 0 };//타일=벌레의 위치 이기때문에 bug라는 이름을 가진 배열을 0으로 초기화 하여 선언. 
	int a=0;//do while문 종료를 위해 조건에 사용될 변수 a
	bug[2][2] = 1;//벌레의 처음위치 카운트 1
	
	srand(time(NULL));//rand함수 사용전에 초기화 하여 실행할때마다 결과를 변경
	
	do{
     
	  walk = rand_walk();//rand_walk 함수를 이용해 벌레의 이동방향을 랜덤으로 정한다.
	  bug_walk(bug);//bug_walk 함수를 이용해 벌레가 이동한 좌표를 1씩 카운트 하여 해당하는 배열 bug[][] 좌표에 저장한다.
	  a=check_string(bug);//do while 문 종료를 위해 check_string 함수를 이용하여 return 값을 a에 저장한다.
	
	}while (a==0);//윗줄에서 받은 a가 0이 아니면 반복문 종료.

	out_tile(bug);// 각 타일별 벌레가 지나간 횟수 출력한다. bug_walk에서 카운트한 배열의 각 원소의 값.
	cout << endl <<"총 이동한 횟수: " << count_walk(bug) << " 입니다." << endl << "그리고" <<endl;//count_walk함수를 이용하여 총 이동횟수를 출력한다.
	find_fist_tile(bug);//find_fist_tile 함수를 이용하여 배열bug[][]의 각 원소를 비교해 가장큰 원소의 좌표와 값을 출력한다.
    
	system("pause");
	return 0;
}


int rand_walk(void)//rand()를 이용해 벌레의 이동방향을 정하는 함수.
{
	return rand() % 8;
}

void bug_walk(int b[5][5]) //벌레의 이동 방향에 따라 이동시키고난후 해당 좌표의 값을 1씩 증가시키는 함수. *초기값:bug[n][m] 이때 (n=2,m=2)
{
	if (walk == 0) { //방향이 0일때 b[n - 1][m] 으로 이동한다
		
		if (n > 0) { //5*5배열 가로열,세로열의 범위 0~4임으로 이조건을 만족해야 범위를 벗어나지 않는다
            
			b[n - 1][m]++;//해당 좌표의 값을 1 증가
		
			n = n - 1;//전역변수 n값을 변화시켜 벌레의 좌표를 현 좌표에서 이동 후 좌표로 만든다
		}
	}

	if (walk == 1) {//방향이 1일때 b[n - 1][m + 1] 으로 이동한다

		if (n > 0 && m < 4) { //5*5배열 가로열,세로열의 범위 0~4임으로 이조건을 만족해야 범위를 벗어나지 않는다

			b[n - 1][m + 1]++;//해당 좌표의 값을 1 증가
			n = n - 1;
			m = m + 1;//전역변수 n,m값을 변화시켜 벌레의 좌표를 현 좌표에서 이동 후 좌표로 만든다
		}

	}

	if (walk == 2) {//방향이 2일때 b[n][m + 1]으로 이동한다
		
		if (m < 4) {//5*5배열 가로열,세로열의 범위 0~4임으로 이조건을 만족해야 범위를 벗어나지 않는다

			b[n][m + 1]++;//해당 좌표의 값을 1 증가
			
			m = m + 1;//전역변수 m값을 변화시켜 벌레의 좌표를 현 좌표에서 이동 후 좌표로 만든다
		}

	}

	if (walk == 3) {//방향이 3일때 b[n + 1][m + 1]으로 이동한다
		if ((n < 4 && m < 4)) {//5*5배열 가로열,세로열의 범위 0~4임으로 이조건을 만족해야 범위를 벗어나지 않는다

			b[n + 1][m + 1]++;//해당 좌표의 값을 1 증가
			n = n + 1;
			m = m + 1;//전역변수 n,m값을 변화시켜 벌레의 좌표를 현 좌표에서 이동 후 좌표로 만든다
		}

	}

	if (walk == 4) {//방향이 4일때 b[n + 1][m]으로 이동한다

		if (n < 4) {//5*5배열 가로열,세로열의 범위 0~4임으로 이조건을 만족해야 범위를 벗어나지 않는다

			b[n + 1][m]++;//해당 좌표의 값을 1 증가
			
			n = n + 1;//전역변수 n값을 변화시켜 벌레의 좌표를 현 좌표에서 이동 후 좌표로 만든다
		}
	}

	if (walk == 5) {//방향이 5일때 b[n + 1][m - 1]으로 이동한다

		if (n < 4 && m < 4) {//5*5배열 가로열,세로열의 범위 0~4임으로 이조건을 만족해야 범위를 벗어나지 않는다

			b[n + 1][m - 1]++;//해당 좌표의 값을 1 증가
			n = n + 1;
			m = m + 1;//전역변수 n,m값을 변화시켜 벌레의 좌표를 현 좌표에서 이동 후 좌표로 만든다
		}
	}

	if (walk == 6) {//방향이 6일때 b[n][m - 1]으로 이동한다

		if (m > 0) {//5*5배열 가로열,세로열의 범위 0~4임으로 이조건을 만족해야 범위를 벗어나지 않는다

			b[n][m - 1]++;//해당 좌표의 값을 1 증가
			
			m = m - 1;//전역변수 m값을 변화시켜 벌레의 좌표를 현 좌표에서 이동 후 좌표로 만든다
		}
	}

	if (walk == 7) {//방향이 7일때 b[n - 1][m - 1]으로 이동한다

		if (n > 0 && m > 0) {//5*5배열 가로열,세로열의 범위 0~4임으로 이조건을 만족해야 범위를 벗어나지 않는다

			b[n - 1][m - 1]++;//해당 좌표의 값을 1 증가
			n = n - 1;
			m = m - 1;//전역변수 n,m값을 변화시켜 벌레의 좌표를 현 좌표에서 이동 후 좌표로 만든다
		}
	}
}

void out_tile(int aa[5][5]) {//bug_walk함수로 완성된 배열의 각 좌표값을 출력하는 함수
	int i, j;

	cout << "배열 tile => " << endl;
	
	for (i = 0; i < 5; i++) {
		    cout << endl;//세로열 변환
		
			for (j = 0; j < 5; j++)
		{
			cout <<"  "<< aa[i][j] <<"  ";//bug_walk함수에서 카운트한 좌표값 출력
		}
	}
}

int count_walk(const int c[5][5]) {//총 이동횟수를 반환하는 함수
	int i, j,sum=0;

	for (i = 0; i < 5; i++) {
		for (j = 0; j < 5; j++) {
			sum += c[i][j];//sum값에 각 좌표의 값들을 모두 더해 넣는다 =>각 좌표의 총합
		}
	}
	return sum;//각 좌표의 총합을 반환
}

int check_string(const int d[5][5]) //모든 타일을 벌레가 지나갔는지 판단하는 함수
{
	int i, j, a = 0;
	for (i = 0; i < 5; i++) {//모든 배열의 좌표를 검사하여 그 값이 하나라도 0이면 return 0 , 모두 0이 아니라면 return 1을 한다.
		for (j = 0; j < 5; j++) {
			if (d[i][j] == 0)
				return 0; //반환 값이 0 이면 main함수에서 do while 문을 빠져나가지 못함
		}
	}
	return 1;//반환 값이 1 이면 main함수에서 do while 문을 빠져나감
}

void find_fist_tile(int t_t[5][5]){ //배열의 각 좌표에 값들을 비교하여 가장큰 좌표와 그 값을 출력하는 함수.
	int i, j;
	int max = t_t[0][0];//좌표 0,0을 가장 큰값라고 가정한다.
	for (i = 0; i < 5; i++) {
		for (j = 0; j < 5; j++) {
			if (t_t[i][j] > max)//모든 배열을 검사하여 0,0좌표의 값보다 크다면 
			{
				max = t_t[i][j];//max에 더 큰 값을 입력한다
				big1 = i, big2 = j;//최종 선별된 i,j 즉 좌표값을 전역변수 big1,2에 넣는다.
			}
		}
	}
	cout << "배열 tile [ " << big1 << " ] [ " << big2 << " ] 을(를) 딱정벌레가" << t_t[big1][big2] << " 번 으로 가장 많이 지나쳤습니다. "<<endl;
}//출력
